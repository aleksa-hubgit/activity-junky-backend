// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package data

import (
	"context"
)

const createActivity = `-- name: CreateActivity :one
INSERT INTO activities (
  id, user_id, category, date, price, name, description, total_places, status
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, user_id, category, date, price, name, description, total_places, status
`

type CreateActivityParams struct {
	ID          int32          `json:"id"`
	UserID      int32          `json:"user_id"`
	Category    string         `json:"category"`
	Date        string         `json:"date"`
	Price       float64        `json:"price"`
	Name        string         `json:"name"`
	Description string         `json:"description"`
	TotalPlaces int32          `json:"total_places"`
	Status      ActivityStatus `json:"status"`
}

func (q *Queries) CreateActivity(ctx context.Context, arg CreateActivityParams) (Activity, error) {
	row := q.db.QueryRow(ctx, createActivity,
		arg.ID,
		arg.UserID,
		arg.Category,
		arg.Date,
		arg.Price,
		arg.Name,
		arg.Description,
		arg.TotalPlaces,
		arg.Status,
	)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Category,
		&i.Date,
		&i.Price,
		&i.Name,
		&i.Description,
		&i.TotalPlaces,
		&i.Status,
	)
	return i, err
}

const createReservation = `-- name: CreateReservation :one
INSERT INTO reservations (
  id, participant_id, activity_id, date
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, participant_id, activity_id, date
`

type CreateReservationParams struct {
	ID            int32  `json:"id"`
	ParticipantID int32  `json:"participant_id"`
	ActivityID    int32  `json:"activity_id"`
	Date          string `json:"date"`
}

func (q *Queries) CreateReservation(ctx context.Context, arg CreateReservationParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, createReservation,
		arg.ID,
		arg.ParticipantID,
		arg.ActivityID,
		arg.Date,
	)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.ParticipantID,
		&i.ActivityID,
		&i.Date,
	)
	return i, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (
  id, participant_id, organizer_id, date, active
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, participant_id, organizer_id, date, active
`

type CreateSubscriptionParams struct {
	ID            int32  `json:"id"`
	ParticipantID int32  `json:"participant_id"`
	OrganizerID   int32  `json:"organizer_id"`
	Date          string `json:"date"`
	Active        bool   `json:"active"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.ID,
		arg.ParticipantID,
		arg.OrganizerID,
		arg.Date,
		arg.Active,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.ParticipantID,
		&i.OrganizerID,
		&i.Date,
		&i.Active,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  username, email, password, user_type
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, username, email, password, user_type
`

type CreateUserParams struct {
	Username string   `json:"username"`
	Email    string   `json:"email"`
	Password string   `json:"password"`
	UserType UserType `json:"user_type"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.UserType,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.UserType,
	)
	return i, err
}

const deleteActivity = `-- name: DeleteActivity :exec
DELETE FROM activities
WHERE id = $1
`

func (q *Queries) DeleteActivity(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteActivity, id)
	return err
}

const deleteReservation = `-- name: DeleteReservation :exec
DELETE FROM reservations
WHERE id = $1
`

func (q *Queries) DeleteReservation(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteReservation, id)
	return err
}

const deleteSubscription = `-- name: DeleteSubscription :exec
DELETE FROM subscriptions
WHERE id = $1
`

func (q *Queries) DeleteSubscription(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteSubscription, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password, user_type FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.UserType,
	)
	return i, err
}

const getUserByEmailOrUsername = `-- name: GetUserByEmailOrUsername :one
SELECT id, username, email, password, user_type FROM users
WHERE email = $1 OR username = $1 LIMIT 1
`

func (q *Queries) GetUserByEmailOrUsername(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmailOrUsername, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.UserType,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password, user_type FROM users
WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.UserType,
	)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, email, password, user_type FROM users
ORDER BY username
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.UserType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateActivity = `-- name: UpdateActivity :exec
UPDATE activities
  set user_id = $2,
  category = $3,
  date = $4,
  price = $5,
  name = $6,
  description = $7,
  total_places = $8,
  status = $9
WHERE id = $1
`

type UpdateActivityParams struct {
	ID          int32          `json:"id"`
	UserID      int32          `json:"user_id"`
	Category    string         `json:"category"`
	Date        string         `json:"date"`
	Price       float64        `json:"price"`
	Name        string         `json:"name"`
	Description string         `json:"description"`
	TotalPlaces int32          `json:"total_places"`
	Status      ActivityStatus `json:"status"`
}

func (q *Queries) UpdateActivity(ctx context.Context, arg UpdateActivityParams) error {
	_, err := q.db.Exec(ctx, updateActivity,
		arg.ID,
		arg.UserID,
		arg.Category,
		arg.Date,
		arg.Price,
		arg.Name,
		arg.Description,
		arg.TotalPlaces,
		arg.Status,
	)
	return err
}

const updateReservation = `-- name: UpdateReservation :exec
UPDATE reservations
  set participant_id = $2,
  activity_id = $3,
  date = $4
WHERE id = $1
`

type UpdateReservationParams struct {
	ID            int32  `json:"id"`
	ParticipantID int32  `json:"participant_id"`
	ActivityID    int32  `json:"activity_id"`
	Date          string `json:"date"`
}

func (q *Queries) UpdateReservation(ctx context.Context, arg UpdateReservationParams) error {
	_, err := q.db.Exec(ctx, updateReservation,
		arg.ID,
		arg.ParticipantID,
		arg.ActivityID,
		arg.Date,
	)
	return err
}

const updateSubscription = `-- name: UpdateSubscription :exec
UPDATE subscriptions
  set participant_id = $2,
  organizer_id = $3,
  date = $4,
  active = $5
WHERE id = $1
`

type UpdateSubscriptionParams struct {
	ID            int32  `json:"id"`
	ParticipantID int32  `json:"participant_id"`
	OrganizerID   int32  `json:"organizer_id"`
	Date          string `json:"date"`
	Active        bool   `json:"active"`
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) error {
	_, err := q.db.Exec(ctx, updateSubscription,
		arg.ID,
		arg.ParticipantID,
		arg.OrganizerID,
		arg.Date,
		arg.Active,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
  set username = $2,
  email = $3,
  password = $4,
  user_type = $5
WHERE id = $1
`

type UpdateUserParams struct {
	ID       int32    `json:"id"`
	Username string   `json:"username"`
	Email    string   `json:"email"`
	Password string   `json:"password"`
	UserType UserType `json:"user_type"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.UserType,
	)
	return err
}
